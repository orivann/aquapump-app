name: Build, Test, and Deploy AquaPump

on:
  push:
    branches:
      - main
      - release/**
  workflow_dispatch: {}

env:
  AWS_REGION: eu-central-1
  ECR_REPOSITORY_BACKEND: aquapump/backend
  ECR_REPOSITORY_FRONTEND: aquapump/frontend
  IMAGE_TAG: ${{ github.sha }}

permissions:
  id-token: write
  contents: read

jobs:
  verify:
    name: Lint & test (${{ matrix.target }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: frontend
            node: '20'
          - target: backend
            python: '3.12'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        if: matrix.target == 'frontend'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
          cache: 'npm'

      - name: Install frontend dependencies
        if: matrix.target == 'frontend'
        run: npm ci

      - name: Lint & build frontend
        if: matrix.target == 'frontend'
        run: |
          npm run lint
          npm run build

      - name: Set up Python
        if: matrix.target == 'backend'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}

      - name: Install backend dependencies
        if: matrix.target == 'backend'
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt

      - name: Run backend smoke tests
        if: matrix.target == 'backend'
        run: pytest backend/tests/smoke

  infra:
    name: Terraform validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Terraform fmt
        run: terraform -chdir=terraform fmt -check

      - name: Terraform init (no backend)
        run: terraform -chdir=terraform init -backend=false -input=false

      - name: Terraform validate
        run: terraform -chdir=terraform validate

  helm:
    name: Helm lint & dry-run
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Helm lint chart
        run: helm lint deploy/helm/aquapump

      - name: Helm template validation
        run: |
          helm template aquapump-dev deploy/helm/aquapump -f deploy/helm/aquapump/values.yaml -f deploy/helm/aquapump/values-dev.yaml
          helm template aquapump-staging deploy/helm/aquapump -f deploy/helm/aquapump/values.yaml -f deploy/helm/aquapump/values-staging.yaml
          helm template aquapump-prod deploy/helm/aquapump -f deploy/helm/aquapump/values.yaml -f deploy/helm/aquapump/values-prod.yaml

      - name: Helm dry-run upgrade
        run: |
          helm upgrade --install aquapump-dev deploy/helm/aquapump --namespace aquapump-dev --dry-run --debug \
            -f deploy/helm/aquapump/values.yaml -f deploy/helm/aquapump/values-dev.yaml
          helm upgrade --install aquapump-staging deploy/helm/aquapump --namespace aquapump-staging --dry-run --debug \
            -f deploy/helm/aquapump/values.yaml -f deploy/helm/aquapump/values-staging.yaml
          helm upgrade --install aquapump-prod deploy/helm/aquapump --namespace aquapump --dry-run --debug \
            -f deploy/helm/aquapump/values.yaml -f deploy/helm/aquapump/values-prod.yaml

  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs:
      - verify
      - infra
      - helm
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS OIDC identity
        run: aws sts get-caller-identity

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build backend image
        run: |
          docker build -f backend/Dockerfile -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_BACKEND }}:${{ env.IMAGE_TAG }} .

      - name: Build frontend image
        run: |
          docker build -f frontend/Dockerfile -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_FRONTEND }}:${{ env.IMAGE_TAG }} .

      - name: Push images
        run: |
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_BACKEND }}:${{ env.IMAGE_TAG }}
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_FRONTEND }}:${{ env.IMAGE_TAG }}

      - name: Update latest tags
        if: github.ref == 'refs/heads/main'
        run: |
          docker tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_BACKEND }}:${{ env.IMAGE_TAG }} ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_BACKEND }}:latest
          docker tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_FRONTEND }}:${{ env.IMAGE_TAG }} ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_FRONTEND }}:latest
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_BACKEND }}:latest
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_FRONTEND }}:latest

  deploy:
    name: Update Helm + Sync Argo CD + Health Check
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://aqua-pump.net
    permissions:
      id-token: write
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Patch Helm image tags
        uses: mikefarah/yq@v4
        with:
          cmd: |
            yq -i '.image.tag = strenv(IMAGE_TAG)' deploy/helm/aquapump/values.yaml
            yq -i '.image.tag = strenv(IMAGE_TAG)' deploy/helm/aquapump/values-prod.yaml
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}

      - name: Commit and push Helm updates
        uses: EndBug/add-and-commit@v9
        with:
          message: "chore(ci): update container tags to ${{ env.IMAGE_TAG }}"
          add: |
            deploy/helm/aquapump/values.yaml
            deploy/helm/aquapump/values-prod.yaml

      - name: Install Argo CD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/v2.11.7/argocd-linux-amd64
          sudo install -m 755 argocd-linux-amd64 /usr/local/bin/argocd

      - name: Sync Argo CD (staging)
        uses: clowdhaus/argo-cd-action@v3.1.0
        with:
          version: v2.11.7
          address: ${{ secrets.ARGOCD_SERVER }}
          auth-token: ${{ secrets.ARGOCD_AUTH_TOKEN }}
          action: sync
          appName: aquapump-staging

      - name: Manual approval for production sync
        uses: chrnorm/deployment-approvals@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          environment: production

      - name: Sync Argo CD (production)
        uses: clowdhaus/argo-cd-action@v3.1.0
        with:
          version: v2.11.7
          address: ${{ secrets.ARGOCD_SERVER }}
          auth-token: ${{ secrets.ARGOCD_AUTH_TOKEN }}
          action: sync
          appName: aquapump-prod

      - name: Check Argo CD app health
        run: |
          echo "Waiting for ArgoCD application to be healthy..."
          for app in aquapump-staging aquapump-prod; do
            healthy=0
            for i in {1..20}; do
              STATUS=$(argocd app get "$app" --server ${{ secrets.ARGOCD_SERVER }} --auth-token ${{ secrets.ARGOCD_AUTH_TOKEN }} --insecure -o json | jq -r '.status.health.status')
              SYNC=$(argocd app get "$app" --server ${{ secrets.ARGOCD_SERVER }} --auth-token ${{ secrets.ARGOCD_AUTH_TOKEN }} --insecure -o json | jq -r '.status.sync.status')
              echo "${app}: Sync=${SYNC} | Health=${STATUS}"
              if [[ "$STATUS" == "Healthy" && "$SYNC" == "Synced" ]]; then
                healthy=1
                break
              fi
              sleep 15
            done
            if [[ $healthy -ne 1 ]]; then
              echo "‚ùå ${app} failed health verification"
              exit 1
            fi
          done
        shell: bash
